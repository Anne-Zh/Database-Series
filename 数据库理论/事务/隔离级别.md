# 事务隔离级别

事务隔离级别有两种常见的实现方案，即锁实现和 MVCC 实现。除了 Infomix 等少数数据库，大部分关系型数据库均采用 MVCC 实现。读未提交、读已提交、可重复读和可序列化这 4 种事务隔离级别的标准，是 ANSI 所定义的基于锁实现的方式。事务的并行度随着隔离级别的增加而衰减，除了并发度最低的可序列化，其他隔离级别都伴随着对一致性的权衡和牺牲。下表是基于锁实现的隔离级别对照表。

| **隔离级别** | **脏读** | **不可重复读** | **幻读** |
| :----------- | :------- | :------------- | :------- |
| 读未提交     | 可能     | 可能           | 可能     |
| 读已提交     | 不可能   | 可能           | 可能     |
| 可重复读     | 不可能   | 不可能         | 可能     |
| 可序列化     | 不可能   | 不可能         | 不可能   |

通过 MVCC 实现的隔离级别实际上只有 SI（快照隔离）和 SSI（可序列化快照隔离）这 2 种。SI 和 SSI 与 ANSI 的 4 种隔离级别并不能完全对照。其中的读未提交，与读已提交在 MVCC 的实现中性能并无差别，可以忽略不计。因此 SI 可以对应为读已提交和可重复读这 2 种隔离级别。实际上，即使是幻读，在 SI 隔离级别中也是不会出现的。由于快照并发控制并不能真正意义上保证事务是“可串行化”的，所以事务间的并发操作依旧有可能引发数据异常现象。但这里的异常不同于之前提到的脏读、丢失更新的异常，而是一种业务数据间逻辑语义层面的异常，也可以说是由于未能满足数据间的语义约束而产生的异常。这被称之为写偏序（Write skew），它的检测可依据并发事务间读写依赖的多版本可串行化图（The multiversion serialization graph）来实现，即 SSI 隔离级别。下表是基于 MVCC 实现的隔离级别对照表。

| **隔离级别** | **脏读** | **不可重复读** | **幻读** | **写偏序** |
| :----------- | :------- | :------------- | :------- | :--------- |
| 读未提交     | 无需实现 | 无需实现       | 无需实现 | 无需实现   |
| 读已提交     | 不可能   | 可能           | 可能     | 可能       |
| 可重复读     | 不可能   | 不可能         | 不可能   | 可能       |
| 可序列化     | 不可能   | 不可能         | 不可能   | 不可能     |

自研 MVCC 引擎是 JDTX 的主要难点之一。JDTX 采用与 PostgreSQL 类似的 MVCC 实现方案，通过 xmin 和 xmax 标记事务快照范围，并在 MVCC 引擎中保存每个数据元祖（Tuple）的 xmin 和 xmax 的事务信息。同一数据的多版本以链表的数据结构存储，通过其 xmin 和 xmax 来获取数据的版本在当前事务快照中的可见性。

由于 MySQL 也并未实现 SSI 隔离级别，因此目前的 JDTX 只是实现了 SI 隔离级别，还并未实现 SSI 隔离级别。MVCC 数据的清理（vacuum）是另一技术难点。过长的事务会导致 MVCC 版本过多，导致占用大量存储空间。尤其是 JDTX 是通过内存来存储 MVCC 的活跃数据，因此对内存空间的释放则更加敏感。由于 JDTX 的异步落盘机制，因此除了 MVCC 标准的垃圾回收逻辑之外，判断数据是否落盘成为清理逻辑的额外规则。

# 隔离级别

## Read Uncommitted | 未提交读

在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读(Dirty Read)。

## Read Committed 提交读

这是大多数数据库系统的默认隔离级别比如 Sql Server, Oracle 等，但不是[MySQL](http://lib.csdn.net/base/14)默认的。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别也支持所谓的不可重复读(Nonrepeatable Read)，因为同一事务的其他实例在该实例处理其间可能会有新的 Commit，所以同一查询可能返回不同结果。

## Repeatable Read | 重复读

当隔离级别设置为 Repeatable Read 时，可以避免不可重复读。不可重复读是指事务 T1 读取数据后，事务 T2 执行更新操作，使 T1 无法再现前一次读取结果。具体地讲，不可重复读包括三种情况：

- 事务 T1 读取某一数据后，事务 T2 对其做了修改，当事务 T1 再次读该数据时，得到与前一次不同的值。例如，T1 读取 B=100 进行运算，T2 读取同一数据 B，对其进行修改后将 B=200 写回数据库。T1 为了对读取值校对重读 B，B 已为 200，与第一次读取值不一致。
- 事务 T1 按一定条件从数据库中读取了某些数据记录后，事务 T2 删除了其中部分记录，当 T1 再次按相同条件读取数据时，发现某些记录神密地消失了。
- 事务 T1 按一定条件从数据库中读取某些数据记录后，事务 T2 插入了一些记录，当 T1 再次按相同条件读取数据时，发现多了一些记录，也就是幻读。

这是 MySQL 的默认事务隔离级别，它确保在一个事务内的相同查询条件的多次查询会看到同样的数据行，都是事务开始时的数据快照。虽然 Repeatable Read 避免了不可重复读，但还有可能出现幻读。简单说，就是当某个事务在读取某个范围内的记录时，另外的一个事务又在该范围内插入新的记录。在之前的事务在读取该范围的记录时，就会产生幻行，InnoDB 通过间隙锁(next-key locking)策略防止幻读的出现。

## Serializable | 序列化

Serializable 是最高的事务隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。该隔离级别代价也花费最高，性能很低，一般很少使用，在该级别下，事务顺序执行，不仅可以避免脏读、不可重复读，还避免了幻读。

# 单对象和多对象操作

在 ACID 中，原子性和隔离性描述了客户端在同一事务中执行多次写入时，数据库应该做的事情：

- 原子性：如果在一系列写操作的中途发生错误，则应中止事务处理，并丢弃当前事务的所有写入。换句话说，数据库免去了用户对部分失败的担忧——通过提供“宁为玉碎，不为瓦全（all-or-nothing）”的保证。

- 隔离性：同时运行的事务不应该互相干扰。例如，如果一个事务进行多次写入，则另一个事务要么看到全部写入结果，要么什么都看不到，但不应该是一些子集。

这些定义假设你想同时修改多个对象（行，文档，记录）。通常需要多对象事务（multi-object transaction） 来保持多块数据同步。譬如执行以下查询来显示用户未读邮件数量：

```sql
$ SELECT COUNT（*）FROM emails WHERE recipient_id = 2 AND unread_flag = true
```

但如果邮件太多，你可能会觉得这个查询太慢，并决定用单独的字段存储未读邮件的数量（一种反规范化）。现在每当一个新消息写入时，必须也增长未读计数器，每当一个消息被标记为已读时，也必须减少未读计数器。在下图中，用户 2 遇到异常情况：邮件列表里显示有未读消息，但计数器显示为零未读消息，因为计数器增长还没有发生。隔离性可以避免这个问题：通过确保用户 2 要么同时看到新邮件和增长后的计数器，要么都看不到。反正不会看到执行到一半的中间结果。

![违反隔离性：一个事务读取另一个事务的未被执行的写入（“脏读”）](https://s2.ax1x.com/2020/02/09/1h2XWQ.md.png)

下图说明了对原子性的需求：如果在事务过程中发生错误，邮箱和未读计数器的内容可能会失去同步。在原子事务中，如果对计数器的更新失败，事务将被中止，并且插入的电子邮件将被回滚。

![原子性确保发生错误时，事务先前的任何写入都会被撤消，以避免状态不一致](https://s2.ax1x.com/2020/02/09/1hRylj.md.png)

多对象事务需要某种方式来确定哪些读写操作属于同一个事务。在关系型数据库中，通常基于客户端与数据库服务器的 TCP 连接：在任何特定连接上，BEGIN TRANSACTION 和 COMMIT 语句之间的所有内容，被认为是同一事务的一部分。另一方面，许多非关系数据库并没有将这些操作组合在一起的方法。即使存在多对象 API（例如，键值存储可能具有在一个操作中更新几个键的多重放置操作），但这并不一定意味着它具有事务语义：该命令可能在一些键上成功，在其他的键上失败，使数据库处于部分更新的状态。

## 单对象写入

当单个对象发生改变时，原子性和隔离也是适用的。例如，假设您正在向数据库写入一个 20 KB 的 JSON 文档：
