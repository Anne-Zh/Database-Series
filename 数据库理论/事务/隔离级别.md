# 事务隔离级别

事务隔离级别有两种常见的实现方案，即锁实现和 MVCC 实现。除了 Infomix 等少数数据库，大部分关系型数据库均采用 MVCC 实现。读未提交、读已提交、可重复读和可序列化这 4 种事务隔离级别的标准，是 ANSI 所定义的基于锁实现的方式。事务的并行度随着隔离级别的增加而衰减，除了并发度最低的可序列化，其他隔离级别都伴随着对一致性的权衡和牺牲。下表是基于锁实现的隔离级别对照表。

| **隔离级别** | **脏读** | **不可重复读** | **幻读** |
| :----------- | :------- | :------------- | :------- |
| 读未提交     | 可能     | 可能           | 可能     |
| 读已提交     | 不可能   | 可能           | 可能     |
| 可重复读     | 不可能   | 不可能         | 可能     |
| 可序列化     | 不可能   | 不可能         | 不可能   |

通过 MVCC 实现的隔离级别实际上只有 SI（快照隔离）和 SSI（可序列化快照隔离）这 2 种。SI 和 SSI 与 ANSI 的 4 种隔离级别并不能完全对照。其中的读未提交，与读已提交在 MVCC 的实现中性能并无差别，可以忽略不计。因此 SI 可以对应为读已提交和可重复读这 2 种隔离级别。实际上，即使是幻读，在 SI 隔离级别中也是不会出现的。由于快照并发控制并不能真正意义上保证事务是“可串行化”的，所以事务间的并发操作依旧有可能引发数据异常现象。但这里的异常不同于之前提到的脏读、丢失更新的异常，而是一种业务数据间逻辑语义层面的异常，也可以说是由于未能满足数据间的语义约束而产生的异常。这被称之为写偏序（Write skew），它的检测可依据并发事务间读写依赖的多版本可串行化图（The multiversion serialization graph）来实现，即 SSI 隔离级别。下表是基于 MVCC 实现的隔离级别对照表。

| **隔离级别** | **脏读** | **不可重复读** | **幻读** | **写偏序** |
| :----------- | :------- | :------------- | :------- | :--------- |
| 读未提交     | 无需实现 | 无需实现       | 无需实现 | 无需实现   |
| 读已提交     | 不可能   | 可能           | 可能     | 可能       |
| 可重复读     | 不可能   | 不可能         | 不可能   | 可能       |
| 可序列化     | 不可能   | 不可能         | 不可能   | 不可能     |

PostgreSQL 的 MVCC 实现方案，通过 xmin 和 xmax 标记事务快照范围，并在 MVCC 引擎中保存每个数据元祖（Tuple）的 xmin 和 xmax 的事务信息。同一数据的多版本以链表的数据结构存储，通过其 xmin 和 xmax 来获取数据的版本在当前事务快照中的可见性。

# 弱隔离级别

如果两个事务不触及相同的数据，它们可以安全地并行（parallel） 运行，因为两者都不依赖于另一个。当一个事务读取由另一个事务同时修改的数据时，或者当两个事务试图同时修改相同的数据时，并发问题（竞争条件）才会出现。并发 BUG 很难通过测试找到，因为这样的错误只有在特殊时机下才会触发。这样的时机可能很少，通常很难重现。并发性也很难推理，特别是在大型应用中，你不一定知道哪些其他代码正在访问数据库。在一次只有一个用户时，应用开发已经很麻烦了，有许多并发用户使得它更加困难，因为任何一个数据都可能随时改变。出于这个原因，数据库一直试图通过提供事务隔离（transaction isolation） 来隐藏应用程序开发者的并发问题。从理论上讲，隔离可以通过假装没有并发发生，让你的生活更加轻松：可序列化（serializable） 的隔离等级意味着数据库保证事务的效果与连续运行（即一次一个，没有任何并发）是一样的。

实际上不幸的是：隔离并没有那么简单。可序列化 会有性能损失，许多数据库不愿意支付这个代价。因此，系统通常使用较弱的隔离级别来防止一部分，而不是全部的并发问题。弱事务隔离级别导致的并发性错误不仅仅是一个理论问题。它们造成了很多的资金损失，耗费了财务审计人员的调查，并导致客户数据被破坏。关于这类问题的一个流行的评论是“如果你正在处理财务数据，请使用 ACID 数据库！”，但是这一点没有提到。即使是很多流行的关系型数据库系统（通常被认为是“ACID”）也使用弱隔离级别，所以它们也不一定能防止这些错误的发生。

# Read Uncommitted | 未提交读

在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读(Dirty Read)。实际上，某些数据库支持该级别，它可以防止脏写，但不防止脏读。
