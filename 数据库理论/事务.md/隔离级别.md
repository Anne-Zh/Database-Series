# 事务隔离

事务隔离级别有两种常见的实现方案，即锁实现和 MVCC 实现。除了 Infomix 等少数数据库，大部分关系型数据库均采用 MVCC 实现。读未提交、读已提交、可重复读和可序列化这 4 种事务隔离级别的标准，是 ANSI 所定义的基于锁实现的方式。事务的并行度随着隔离级别的增加而衰减，除了并发度最低的可序列化，其他隔离级别都伴随着对一致性的权衡和牺牲。下表是基于锁实现的隔离级别对照表。

| **隔离级别** | **脏读** | **不可重复读** | **幻读** |
| :----------- | :------- | :------------- | :------- |
| 读未提交     | 可能     | 可能           | 可能     |
| 读已提交     | 不可能   | 可能           | 可能     |
| 可重复读     | 不可能   | 不可能         | 可能     |
| 可序列化     | 不可能   | 不可能         | 不可能   |

通过 MVCC 实现的隔离级别实际上只有 SI（快照隔离）和 SSI（可序列化快照隔离）这 2 种。SI 和 SSI 与 ANSI 的 4 种隔离级别并不能完全对照。其中的读未提交，与读已提交在 MVCC 的实现中性能并无差别，可以忽略不计。因此 SI 可以对应为读已提交和可重复读这 2 种隔离级别。实际上，即使是幻读，在 SI 隔离级别中也是不会出现的。由于快照并发控制并不能真正意义上保证事务是“可串行化”的，所以事务间的并发操作依旧有可能引发数据异常现象。但这里的异常不同于之前提到的脏读、丢失更新的异常，而是一种业务数据间逻辑语义层面的异常，也可以说是由于未能满足数据间的语义约束而产生的异常。这被称之为写偏序（Write skew），它的检测可依据并发事务间读写依赖的多版本可串行化图（The multiversion serialization graph）来实现，即 SSI 隔离级别。下表是基于 MVCC 实现的隔离级别对照表。

| **隔离级别** | **脏读** | **不可重复读** | **幻读** | **写偏序** |
| :----------- | :------- | :------------- | :------- | :--------- |
| 读未提交     | 无需实现 | 无需实现       | 无需实现 | 无需实现   |
| 读已提交     | 不可能   | 可能           | 可能     | 可能       |
| 可重复读     | 不可能   | 不可能         | 不可能   | 可能       |
| 可序列化     | 不可能   | 不可能         | 不可能   | 不可能     |

自研 MVCC 引擎是 JDTX 的主要难点之一。JDTX 采用与 PostgreSQL 类似的 MVCC 实现方案，通过 xmin 和 xmax 标记事务快照范围，并在 MVCC 引擎中保存每个数据元祖（Tuple）的 xmin 和 xmax 的事务信息。同一数据的多版本以链表的数据结构存储，通过其 xmin 和 xmax 来获取数据的版本在当前事务快照中的可见性。

由于 MySQL 也并未实现 SSI 隔离级别，因此目前的 JDTX 只是实现了 SI 隔离级别，还并未实现 SSI 隔离级别。MVCC 数据的清理（vacuum）是另一技术难点。过长的事务会导致 MVCC 版本过多，导致占用大量存储空间。尤其是 JDTX 是通过内存来存储 MVCC 的活跃数据，因此对内存空间的释放则更加敏感。由于 JDTX 的异步落盘机制，因此除了 MVCC 标准的垃圾回收逻辑之外，判断数据是否落盘成为清理逻辑的额外规则。
