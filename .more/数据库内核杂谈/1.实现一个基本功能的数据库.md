# 实现一个基本功能的数据库

今天我们摒弃直接介绍数据库内核各个模块的思路，而是从应用开发者的角度出发，来看实现一个数据库需要哪些基本功能，然后把这些功能细分成最小的模块再手把手一起实现，帮你揭开数据库内核的神秘面纱。希望能够减轻你对学习数据库内核的压力。我们也可以从中体会到，九层之台，起于累土。所有复杂的系统，都是通过模块化的架构和设计，以及工程阶段的精益求精，一步一步累计起来。

对与应用开发者而言，一个数据库需要哪些必要的功能呢？我觉得，下面这些是必不可少的：

1）创建数据库和数据表：create database，schema, table 等
2）存储数据：insert /update 数据，或者从其他方式导入数据(比如 csv 文件)
3）读取查询数据：通过 SQL 语句，对数据进行读取和查询，比如 sort，aggregate，filter 等

# 创建和存储数据

当用户创建一个新的数据库，并导入数据时，数据库系统就需要存储这些数据。说到存储，第一个想法就是文件系统（其实说到底数据库系统就是一个特殊的文件系统，区别与普通文件系统提供的的读写文件的接口，数据库只是提供了一个面向数据的接口：存储，读取和查询；整个系统为这些接口提供服务)。以下图 student 表作为示例，要怎么把这张表存在文件中呢？

![Student 表](https://pic1.imgdb.cn/item/63667b6016f2c2beb1b14bda.jpg)

读取 CSV 文件的逻辑也非常简单: 一行一行读取数据，然后根据";"把每个数据段取出。除了 CSV 存储，另一种常见的方式就是 json 格式:

```json
[ {"id":1, "name":"Xiaoputao", "class":3, "hobby":"running}, ... ]
```

聊聊 CSV 和 JSON 存储的优缺点。两者都属于文本存储，优点一在于易于人类理解。另一个优点就是直接兼容其他支持 CSV 和 JSON 的数据库。缺点也很明显，存储效率不高，读取效率也会随之降低。另一个问题在于，上述例子中存储的内容只有值，没有 type 和 size(metadata)，这些信息在后续操作如校验中是很重要的。当然，我们可以把 metadata 加入到存储中，比如，把 json 的每个 val 变成一个 obj:{“colName”:“id”,“colType”:“int”,“colSize”:4,“colVal”:1}。专业数据库肯定不会选择用 CSV 或 JSON 作为默认存储，但几乎都支持 CSV 和 JSON 数据作为 external table。如果要追求更高的性能，我们可以选择更高效的编码方式把数据以字节流的形式存储在文件中；只要数据库系统自身能够读取这些数据即可。咱们既然时间有限，当然是一切从简，就选择 CSV 或者 JSON 的文件格式来存储我们的数据。

# 读取数据

基于上述用 CSV 或 JSON 的存储，读取数据非常简单(允许我们调用第三方支持 CSV 或者 JSON 的 API)。重点在于读取完存放在怎样一个数据结构中方便后续对数据进一步的查询操作。根据数据的特性，结果集(RowSet)是由一序列的行数据(Row)组成，每一行又由多个单元(Cell)组成。我们试着根据这个概念设计下面这些类：

![Cell, Row, RowSet Class](https://pic1.imgdb.cn/item/63667e6c16f2c2beb1c7db40.jpg)

简单梳理下，每个 Cell 存 type，size，和 value；Row 存一整行 cell；RowSet 存一序列的 Row。具体在实现中还有很多细节需要注意，如 typecheck, 确保每行列数相同，等等，这里也一并从简略过。定义了存储方式和数据结构，具体数据读取代码如下:

![读取](https://pic1.imgdb.cn/item/63667eae16f2c2beb1c99330.jpg)

csvToRowSet 和 jsonToRowSet 的实现只需要借助第三方 CSV 和 JSON 的类库就能实现，就不赘述代码了。这一节里，我们定义了 Cell, Row, RowSet 的数据结构来存放从文件(CSV 或 JSON)中读取的数据，并给出了示例代码。

# 执行查询

有了存储和读取，已经可以把数据从文件中读取到内存，接下来就要支持用户的查询语句了。实现查询就是去实现 SQL 语句中的各个功能模块，比如排序(order by), 聚合(group by)，多表联合(join)等等。执行器会对每个功能模块进行实现，甚至针对不同的数据分布，会有多种方式的实现来提高读取速度。现在，我们一起来讨论一些常用的语言功能。

## 全表读取(`SELECT *`)

其实，定义了 RowSet 的数据结构和实现了读取文件的接口，我们的数据库就已经支持全表读取的 SQL 语句，示例如下：

```sql
SELECT * FROM student;
```

## 分页语句(LIMIT)

![Limit Operator](https://pic1.imgdb.cn/item/6366801d16f2c2beb1d2985b.jpg)

## 关系映射语句(PROJECTION)

关系映射的本质是对于输入的 RowSet 的每一行(row), 通过各种标量计算，输出一个新的数据行，再由这些行组成新的 RowSet。见下图示例：

```sql
SELECT id + 5, LEN(name) FROM student;
```

对从 student 表读取的每一行数据，输出一个新的数据行包含 id + 5 和 LEN(name)的 cells。Projection 可以非常复杂，但有一条准则就是它不改变原有 RowSet 的基数(cardinality), 即新 RowSet 的行数和原来的相同。因此，无论映射逻辑多复杂，输入一个 Row，输出一个 Row。再复杂的计算，也是一比一步迭代产生。比如上述示例可以分解成下面这些操作来完成：对于每一行 input row, id 值加 5，对 name 取 length，最后去掉 class 和 hobby 两列。归根结底就是将复杂的运算拆分成原子操作然后一步一步地顺序执行。我们可以定义如下两个基本 operator：RowComputeOperator 根据定义的 computeCellVal 对 input row 计算一个新 cell，并把这个 cell 加到原 row 的末尾。SelectionOperator 根据给定的 indexes，生成一个仅包含指定 index 的新 row。Pseudo code 如下：
