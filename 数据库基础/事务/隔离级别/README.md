# 事务隔离级别

在前面章节中，我们介绍了事务的 ACID 特性，即原子性、一致性、隔离性、持久性；但是多个事务同时执行的时候，就可能出现脏读，不可重复读，幻读等现象：

- 脏读：一个客户端读取到另一个客户端尚未提交的写入。读已提交或更强的隔离级别可以防止脏读。
- 脏写：一个客户端覆盖写入了另一个客户端尚未提交的写入。几乎所有的事务实现都可以防止脏写。
- 读取偏差（不可重复读）：在同一个事务中，客户端在不同的时间点会看见数据库的不同状态。快照隔离经常用于解决这个问题，它允许事务从一个特定时间点的一致性快照中读取数据。快照隔离通常使用多版本并发控制（MVCC）来实现。
- 更新丢失：两个客户端同时执行读取-修改-写入序列。其中一个写操作，在没有合并另一个写入变更情况下，直接覆盖了另一个写操作的结果。所以导致数据丢失。快照隔离的一些实现可以自动防止这种异常，而另一些实现则需要手动锁定（SELECT FOR UPDATE）。
- 写偏差：一个事务读取一些东西，根据它所看到的值作出决定，并将决定写入数据库。但是，写入的时候，决定的前提不再是真实的。只有可序列化的隔离才能防止这种异常。
- 幻读：事务读取符合某些搜索条件的对象。另一个客户端进行写入，影响搜索结果。快照隔离可以防止直接的幻像读取，但是写入歪斜环境中的幻影需要特殊处理，例如索引范围锁定。

为了解决这些问题，就有了隔离级别的概念，SQL 标准的事务隔离级别包括：读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化/可序列化（serializable）。其中，这些不同的隔离级别可以分为弱隔离级别与可序列化两大类，弱隔离级别可以防止这些异常情况，但是让应用程序开发人员手动处理其他应用程序（例如，使用显式锁定）。只有可序列化的隔离才能防范所有这些问题，不过隔离得越严实，效率就会越低。事务的并行度随着隔离级别的增加而衰减，除了并发度最低的可序列化，其他隔离级别都伴随着对一致性的权衡和牺牲。

## 事务隔离的实现方案

事务隔离级别有两种常见的实现方案，即锁实现和 MVCC 实现；其中除了 Infomix 等少数数据库，大部分关系型数据库均采用 MVCC 实现。下表是基于锁实现的隔离级别对照表。

| 隔离级别 | 脏读脏写 | 不可重复读 | 幻读   |
| :------- | :------- | :--------- | :----- |
| 读未提交 | 可能     | 可能       | 可能   |
| 读已提交 | 不可能   | 可能       | 可能   |
| 可重复读 | 不可能   | 不可能     | 可能   |
| 可序列化 | 不可能   | 不可能     | 不可能 |

而基于 MVCC 实现的隔离级别对照表与基于锁的也是有所区别：

| 隔离级别 | 脏读脏写 | 不可重复读 | 幻读     | 写偏序   |
| :------- | :------- | :--------- | :------- | :------- |
| 读未提交 | 无需实现 | 无需实现   | 无需实现 | 无需实现 |
| 读已提交 | 不可能   | 可能       | 可能     | 可能     |
| 可重复读 | 不可能   | 不可能     | 不可能   | 可能     |
| 可序列化 | 不可能   | 不可能     | 不可能   | 不可能   |

通过 MVCC 实现的隔离级别实际上只有 SI（快照隔离）和 SSI（可序列化快照隔离）这 2 种。SI 和 SSI 与 ANSI 的 4 种隔离级别并不能完全对照。其中的读未提交，与读已提交在 MVCC 的实现中性能并无差别，可以忽略不计。因此 SI 可以对应为读已提交和可重复读这 2 种隔离级别。实际上，即使是幻读，在 SI 隔离级别中也是不会出现的。由于快照并发控制并不能真正意义上保证事务是可串行化的，所以事务间的并发操作依旧有可能引发数据异常现象。但这里的异常不同于之前提到的脏读、丢失更新的异常，而是一种业务数据间逻辑语义层面的异常，也可以说是由于未能满足数据间的语义约束而产生的异常。这被称之为写偏序（Write skew），它的检测可依据并发事务间读写依赖的多版本可串行化图（The multiversion serialization graph）来实现，即 SSI 隔离级别。
