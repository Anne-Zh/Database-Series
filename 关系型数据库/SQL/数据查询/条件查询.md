# SQL 基础语法

```sql
expression IS NOT NULL

SELECT *
FROM contacts
WHERE last_name IS NOT NULL;
```

页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决；索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。

# Case-When

Case 具有两种格式。简单 Case 函数和 Case 搜索函数。

```sql
CASE expression
    WHEN condition1 THEN result1
    WHEN condition2 THEN result2
   ...
    WHEN conditionN THEN resultN
    ELSE result
END as field_name

-- 简单Case函数
CASE sex
WHEN '1' THEN '男'
WHEN '2' THEN '女'
ELSE '其他' END

-- Case搜索函数
CASE WHEN sex = '1' THEN '男'
WHEN sex = '2' THEN '女'
ELSE '其他' END sex_description
```

这两种方式，可以实现相同的功能。简单 Case 函数的写法相对比较简洁，但是和 Case 搜索函数相比，功能方面会有些限制，比如写判断式。
还有一个需要注意的问题，Case 函数只返回第一个符合条件的值，剩下的 Case 部分将会被自动忽略。

```
--比如说，下面这段SQL，你永远无法得到“第二类”这个结果
CASE WHEN col_1 IN ( 'a', 'b') THEN '第一类'
WHEN col_1 IN ('a')       THEN '第二类'
ELSE'其他' END
```

有如下数据:(为了看得更清楚，我并没有使用国家代码，而是直接用国家名作为 Primary Key)

| 国家(country) | 人口(population) |
| ------------- | ---------------- |
| 中国          | 600              |
| 美国          | 100              |
| 加拿大        | 100              |
| 英国          | 200              |
| 法国          | 300              |
| 日本          | 250              |
| 德国          | 200              |
| 墨西哥        | 50               |
| 印度          | 250              |

根据这个国家人口数据，统计亚洲和北美洲的人口数量。应该得到下面这个结果。

| 洲     | 人口 |
| ------ | ---- |
| 亚洲   | 1100 |
| 北美洲 | 250  |
| 其他   | 700  |

想要解决这个问题，你会怎么做？生成一个带有洲 Code 的 View，是一个解决方法，但是这样很难动态的改变统计的方式。
如果使用 Case 函数，SQL 代码如下:

```sql
SELECT  SUM(population),
CASE country
WHEN '中国'     THEN '亚洲'
WHEN '印度'     THEN '亚洲'
WHEN '日本'     THEN '亚洲'
WHEN '美国'     THEN '北美洲'
WHEN '加拿大'  THEN '北美洲'
WHEN '墨西哥'  THEN '北美洲'
ELSE '其他' END
FROM    Table_A
GROUP BY CASE country
WHEN '中国'     THEN '亚洲'
WHEN '印度'     THEN '亚洲'
WHEN '日本'     THEN '亚洲'
WHEN '美国'     THEN '北美洲'
WHEN '加拿大'  THEN '北美洲'
WHEN '墨西哥'  THEN '北美洲'
ELSE '其他' END;
```

同样的，我们也可以用这个方法来判断工资的等级，并统计每一等级的人数。SQL 代码如下；

```sql
SELECT
CASE WHEN salary <= 500 THEN '1'
WHEN salary > 500 AND salary <= 600  THEN '2'
WHEN salary > 600 AND salary <= 800  THEN '3'
WHEN salary > 800 AND salary <= 1000 THEN '4'
ELSE NULL END salary_class,
COUNT(*)
FROM    Table_A
GROUP BY
CASE WHEN salary <= 500 THEN '1'
WHEN salary > 500 AND salary <= 600  THEN '2'
WHEN salary > 600 AND salary <= 800  THEN '3'
WHEN salary > 800 AND salary <= 1000 THEN '4'
ELSE NULL END;
```

还可以用一个 SQL 语句完成不同条件的分组合并：
有如下数据

| 国家(country) | 性别(sex) | 人口(population) |
| ------------- | --------- | ---------------- |
| 中国          | 1         | 340              |
| 中国          | 2         | 260              |
| 美国          | 1         | 45               |
| 美国          | 2         | 55               |
| 加拿大        | 1         | 51               |
| 加拿大        | 2         | 49               |
| 英国          | 1         | 40               |
| 英国          | 2         | 60               |

按照国家和性别进行分组，得出结果如下

| 国家   | 男  | 女  |
| ------ | --- | --- |
| 中国   | 340 | 260 |
| 美国   | 45  | 55  |
| 加拿大 | 51  | 49  |
| 英国   | 40  | 60  |

普通情况下，用 UNION 也可以实现用一条语句进行查询。但是那样增加消耗(两个 Select 部分)，而且 SQL 语句会比较长。下面是一个是用 Case 函数来完成这个功能的例子

```sql
SELECT country,
SUM( CASE WHEN sex = '1' THEN
population ELSE 0 END),  --男性人口
SUM( CASE WHEN sex = '2' THEN
population ELSE 0 END)   --女性人口
FROM  Table_A
GROUP BY country;
```

这样我们使用 Select，完成对二维表的输出形式，充分显示了 Case 函数的强大。
